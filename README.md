# N-Queen-Problem
backtracking &amp; forward-checking


    使用回溯算法和向前检测算法解决N皇后问题。
    
    尝试使用几种方法分别实现BT和FC，因此BT和FC分别有几个代码版本。

      - BT 
        - 使用树结点存储结点状态，求出解的路径。
        - 优化存储结构，使用更简化的结构存储变量和域值，减少变量的使用。
        - 分别设计求单个解和所有解的代码。
      - FC
        - 使用树结点存储结点状态，求出解的路径。
        - 优化存储结构，使用更简化的结构存储变量和域值，减少变量的使用。
        - 分别设计求单个解和所有解的代码。
        - 使用MRV优化探索路径，提高运行效率。

    虽然各个版本不一样，但是算法思想是一致的，不过由于存储结构和优化方法不一样，
    因此编写多个版本，同时由于求所有解和求单个解的写法有部分不同，因此也分开写，
    设置求单个解是为了更好地比较不同N时程序运行的效率，这是因为N越大，其所有解
    是非常庞大，因此没有办法在常规时间跑出来，因此选择求单个解进行比较。

    经过优化，BT和FC效率都有明显的提高，特别是对存储结构的优化，空间复杂度的减少
    极大地减少了时间复杂度，同时，经过优化的FC再加上MRV优化有了质的提高，没有加
    入MRV前，FC跑N=22时，已经需要20.1s，加入MRV后，FC跑N=22只需要0.001s，同时
    可以轻松处理更大的N，当N=100时，只需要0.1019 s，可见效率非常高。
    
    
    8个代码文件分别表示8个版本
      BT_all  输出全部解
      BT_optimization  优化版本的BT 求一个解
      BT_Tree  树形结构版本的BT 求一个解

      FC_all 输出全部解
      FC_optimization 优化版本的FC   求一个解
      FC_optimization_MRV 优化版本的FC+MRV   求一个解
      FC_Tree 树形结构版本的FC   求一个解
      FC_Tree_MRV  树形结构的FC+MRV   求一个解
